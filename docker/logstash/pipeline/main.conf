input {
  beats {
    port => 5044
  }
}

filter {
  if [log][file][path] and [log][file][path] =~ "/data/logs/.+_.+_.+_.+_.+\\.log$" {
    grok {
      match => {
        "[log][file][path]" => ".*/%{DATA:src_os}_%{DATA:src_host}_%{IP:src_ip}_%{DATA:src_net}_%{DATA:src_type}\\.log"
      }
      tag_on_failure => ["_grok_path_failure"]
    }
    if "_grok_path_failure" not in [tags] {
      mutate {
        add_field => {
          "[host][name]" => "%{src_host}"
          "[host][ip]" => "%{src_ip}"
          "[host][os][type]" => "%{src_os}"
          "[network][name]" => "%{src_net}"
          "log_type" => "%{src_type}"
        }
      }
    }
  }

  if [agent][type] == "winlogbeat" {
    mutate { add_field => { "log_type" => "winlog" } }
  } else if [message] =~ /HTTP\/\d\.\d"/ {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
      tag_on_failure => ["_grok_apache_failure"]
    }
    mutate { add_field => { "log_type" => "apache" } }
  } else if [message] =~ /sshd|sudo|auth/ {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{DATA:syslog_host} %{DATA:program}: %{GREEDYDATA:syslog_message}" }
      tag_on_failure => ["_grok_syslog"]
    }
    grok {
      match => { "program" => "%{DATA:program_name}\\[%{POSINT:pid}\\]" }
      tag_on_failure => ["_grok_program"]
    }
    if [syslog_timestamp] {
      date {
        match => ["syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss"]
        target => "@timestamp"
      }
    }
    mutate { add_field => { "log_type" => "syslog" } }

    if [syslog_message] =~ /Failed password/ {
      grok {
        match => {
          "syslog_message" => "Failed password for (invalid user )?%{DATA:target_user} from %{IP:source_ip} port %{NUMBER:source_port} ssh2"
        }
        tag_on_failure => ["_grok_ssh_failed"]
      }
      mutate {
        add_field => {
          "[event][category]" => "authentication"
          "[event][action]" => "login_failed"
          "[source][ip]" => "%{source_ip}"
          "[source][port]" => "%{source_port}"
          "[user][name]" => "%{target_user}"
        }
      }
    } else if [syslog_message] =~ /Accepted password/ {
      grok {
        match => {
          "syslog_message" => "Accepted password for %{DATA:target_user} from %{IP:source_ip} port %{NUMBER:source_port} ssh2"
        }
        tag_on_failure => ["_grok_ssh_ok"]
      }
      mutate {
        add_field => {
          "[event][category]" => "authentication"
          "[event][action]" => "login_success"
          "[source][ip]" => "%{source_ip}"
          "[source][port]" => "%{source_port}"
          "[user][name]" => "%{target_user}"
        }
      }
    } else if [syslog_message] =~ / sudo: / or [program] == "sudo" or [program_name] == "sudo" {
      grok {
        match => {
          "syslog_message" => "%{DATA:actor_user} : TTY=%{DATA:tty} ; PWD=%{DATA:pwd} ; USER=%{DATA:target_user} ; COMMAND=%{GREEDYDATA:command}"
        }
        tag_on_failure => ["_grok_sudo"]
      }
      mutate {
        add_field => {
          "[event][category]" => "privilege"
          "[event][action]" => "sudo"
          "[user][name]" => "%{actor_user}"
          "[user][target][name]" => "%{target_user}"
          "[process][command_line]" => "%{command}"
        }
      }
    }
  } else {
    mutate { add_field => { "log_type" => "app" } }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "logs-%{+YYYY.MM.dd}"
  }
  stdout {
    codec => rubydebug
  }
}
